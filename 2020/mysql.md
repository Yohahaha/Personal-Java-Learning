#### 事务

##### 四大特性

Atomic - 原子性

> 事务是一个不可分割的操作，要么全部执行，要么都不执行

Consistency - 一致性

> 事务前后，数据库的完整性约束没有被破坏

Isolation - 隔离性

> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致

Durability - 持久性

> 事务结束之后，其对数据库中数据所做的修改是永久性的

##### 多事务并发可能出现的问题

- 更新丢失：当两个事务同时更新一条数据时，A事务可能将B事务还未提交的数据再次更新，导致两个事务都更新失败，丢失更新信息
- 脏读：A事务读取到B事务更新但未提交的数据，但B事务回滚了，A事务读到的就是脏数据
- 不可重复读：在同一事务中对一行数据的两次读取得到不同的结果
- 幻读：事务在执行过程中进行两次查询，后一次查询的结果出现了前一次查询中没有出现过或者缺少的结果，如在A事务两次读取同一条记录中间，B事务对该记录进行了修改，导致A事务第二次读取读到了不一样的结果

##### 事务隔离级别

- 读未提交：事务A可以读到事务B修改但还未提交的数据，但不能修改它
- 读提交：事务B的修改（写操作）只有在提交之后才可以被事务A看到
- 可重复读：一个事务执行过程中看到的数据总是和事务开始时看到的数据是一致的，**MySQL默认隔离级别**
- 串行化：对读写操作都加锁

##### 实现原理

- 通过创建视图使得访问的时候以视图的逻辑结果为主
- 读未提交：直接返回记录上的最新值，没有视图概念
- 读提交：视图是在SQL开始执行时创建
- 可重复读：视图在事务开启时创建，事务执行过程中都使用该视图
- 串行化：直接用加锁的方式避免并行访问

##### 具体实现

每条记录在更新的时候都会记录一条回滚操作，同一条记录在系统中存在多个版本，称为**多版本并发控制MVCC**。

InnoDB中每个事务都有唯一的事务ID：transaction_id，它是在事务开始时向InnoDB的事务系统申请的，严格递增。每次事务更新数据时都会生成一个新的数据版本，并将自己的transaction_id赋值过去，记为row_trx_id。同时旧的数据版本保留，也就是说，表中的一行记录可能有多个版本，每个版本有自己的row_trx_id

![](<https://user-images.githubusercontent.com/34979747/69492288-9cd43100-0edb-11ea-94f2-7d00df7bf796.png>)

按照可重复读的级别，一个事务启动时只能看到它之前生成的数据版本，如果一个数据版本是它之后生成的，则必须找到其上一个版本的数据。所以，InnoDB在事务启动时为其创建了一个数组，用于保存当前事务启动时所有活跃的事务id，就是启动了还未提交的所有事务。数组中事务ID最小值称为“低水位”，目前已创建的事务的ID的最大值加1记为“高水位”。根据这个数组，将数据的row_trx_id与其比对即可确定可见与否。**InnoDB利用所有数据都有多个版本的特性，实现秒级创建快照**。

##### 事务启动方式

- 显式启动事务：begin / start transaction，commit，rollback
- set autocommit = 0，该命令会把这个线程的自动提交关闭。只要执行一个select语句，事务就启动且不会自动提交，直到主动commit或者rollback或者断开连接
- 建议使用第一种启动事务方式：如果考虑多一次begin交互过程，可以使用commit work and chain语法。在 autocommit = 1 时，用begin显式开启事务，如果执行commit则提交事务；如果执行commit work and chain 则提交事务并且自动启动下一个事务

##### 事务启动的时机

- begin/start transaction 命令不是一个事务的起点，在执行到它之后的第一个操作InnoDB表的语句时，事务才真正启动。它的一致性视图是在执行第一个快照读语句时创建的
- 使用start transaction with consistent snapshot 马上启动一个事务。它的一致性视图是在执行这条语句时创建的

##### 长事务

在该事务提交之前会记录大量的回滚日志，占用空间，占用锁，影响性能。

##### 避免长事务

- 开发端
  - 确认是否使用了set autocommit = 0 ，可以开启MySQL的general_log，随便跑一个业务逻辑，通过日志来确认，要做的就是把它改过来
  - 确认是否有不必要的只读事务
  - 业务连接数据库时根据业务本身的预估，设置 SET MAX_EXECUTION_TIME 命令来控制每个语句的最长时间，避免单个语句意外执行太长时间
- 数据库端
  - 监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警或者kill
  - 在业务功能测试时输出所有的general_log 分析日志行为提前发现问题

