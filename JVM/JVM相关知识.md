## java内存区域

### 运行时数据区域

#### 程序计数器

##### 特点

可以看作是当前线程执行的字节码的行号指示器

每个线程都有一个独立的程序计数器，各个线程之间计数器互不影响，是线程私有的。

如果线程执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器值为空（Undefined）

##### 异常

此内存区域是唯一一个没有OOM异常的区域

#### Java虚拟机栈

##### 特点

**线程私有**，声明周期和线程同步

每个方法执行时都会创建一个**栈帧**，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈和出栈的过程。

一般的“栈”就指的是虚拟机栈中的**局部变量表**

局部变量表存放了编译期可知的各种基本数据类型。它所需的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈帧中需要的局部变量空间是完全确定的，运行期间不会改变。

##### 异常

如果线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError

如果虚拟机栈可以动态扩展（一般都可以），扩展时无法申请到足够的内存时，就抛出OOM

#### 本地方法栈

和虚拟机栈类似，区别是：虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机执行Native方法服务

也会抛出SOE和OOM

#### Java堆

##### 特点

Java堆是被所有线程共享的一块区域，在虚拟机启动时创建

唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存

Java堆可处于物理上不连续的内存空间中，只要逻辑上连续即可

通过 `-Xmx` 和 `-Xms` 控制堆扩展大小

##### 异常

在堆中没有内存完成实例分配，并且堆无法再扩展时，抛出OOM

#### 方法区

##### 特点

线程共享的区域

存储已经被虚拟机加载的类信息、常量、静态变量等

##### 异常

也会抛出OOM

##### 运行时常量池

是方法区的一部分，存放编译期生成的各种字面量和符号引用

#### 直接内存

在NIO中，可以通过channel和buffer进行IO，可以使用Native函数库分配堆外内存，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆之间复制数据，影响性能

## 垃圾收集器

### 基本概念

垃圾收集（Garbage Collection，GC）的任务

- 哪些内存需要回收
- 什么时候回收
- 如何回收

java内存运行时，程序计数器、虚拟机栈、本地方法栈三个区域是随着线程而生而灭的：栈中的栈帧分配的内存基本是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性，方法结束时或者线程结束时，内存自然跟着回收了。

java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，只有在程序运行期才会知道要创建哪些对象，这部分内存的分配和回收都是动态的，GC关注的也是这部分内存。

### 对象引用问题

堆中存放着几乎所有的对象实例，GC在对堆进行回收时，第一件事就是去判断哪些对象还“活着”，哪些对象“死亡”。

#### 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；引用失效时就减1；当计数器为0时就表示不能再被使用。

该算法实现简单，判定效率也高，但在Java虚拟机中没有采用这种算法，其最主要的原因在于该算法无法解决“循环引用问题”。

#### 可达性分析算法

主流的商用程序语言都是通过可达性分析来判定对象是否存活。该算法的基本思路就是通过一系列被称为“GC Roots”的对象为起点，开始向下搜索，搜索路径称为引用链。当一个对象与GC Root之间没有任何引用链时，该对象就是不可用的。

###### Java中，可作为GC Root的对象如下

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即Native方法）引用的对象

#### 引用类型

**强引用**：new出来的对象引用，只要强引用还存在，垃圾收集器就永远不会回收被引用的对象

**软引用**：还有用但非必需的对象。对于软引用关联的对象，在系统即将内存溢出之前，会对这些对象列进回收列表中进行第二次回收。如果这次回收还没有足够的内存，就抛出内存溢出异常。

**弱引用**：非必需对象，其强度比软引用更弱。被弱引用关联的对象只能活到下一次GC发生之前。当GC发生时，无论当前内存是否足够，都会回收弱引用的对象。

**虚引用**：最弱的一种引用关系。一个对象是否有虚引用的存在不会对其生存时间有任何影响，也无法通过虚引用来获取一个对象实例。它存在的唯一目的就是该对象在GC时收到一个系统通知。

### GC算法

#### 标记-清除（Mark-Sweep）

- 算法分为两步，第一步标记所有需要回收的对象；第二步统一回收这些被标记的对象

- 类似于打扫屋子的“定点清除”

- 不足

- - 效率问题：标记和清除的效率都不高
  - 空间问题：清除后会产生内存碎片，不利于大对象的分配，可能会引起多次GC

#### 复制（Copying）

- 为了解决效率问题

- 将内存区域划分为两部分，一次只使用其中的一块，当这块内存用完之后，标记出其中还存活的对象，将其复制到另一块内存中，最后将这块内存完全清除

- 商业的JVM都采用这种方法，但在区域划分时的比例不是这样。

- - 在新生代中，98%的对象都是“朝生夕死”的，所以将内存分为一块Eden区和两块较小的Survive区，每次使用Eden和一块Servive区，当发生GC时，将存活的对象都移动到那块没有使用的Survive区，清理Eden和刚才使用的Survive区。
  - 一般Eden和Survive的比例为8：1
  - 当那块小的Survive不够用时，需要依赖老年代进行分配担保（handle       promotion）

- 类似于打扫屋子时将两块地板上的垃圾先统一扫到其中一块上，然后再清扫那一块脏的。

#### 标记-整理（Mark-Compact）

- 或者是标记-压缩？
- 当对象存活率很高时，会执行较多的复制操作，效率会降低。所以在老年代中不能使用复制算法
- 该算法与标记-清除算法类似，不同的是在标记过后不执行清除，而是将所有存活的对象都向一端移动，然后直接清理之外的内存。



### GC算法的实现（HotSpot）

#### 枚举根节点

- 在可达性分析中需要确定GC root节点，可以作为GC root的节点主要存在于全局性的引用和执行上下文中。但应用很大，不可能一一检查里面的引用，会消耗很多时间。
- 可达性分析还会因为GC停顿而受影响，这些工作需要在一个确保一致性的快照中，也就是说在整个分析过程中应用的执行过程仿佛被冻结在某一时间点上。**这也是为什么GC时需要STW的一个原因。**
- STW时，JVM需要知道在哪些地方存放着对象引用，但不能去一个个的扫描检查。
- 在HotSpot的实现中，使用一组称为OopMap的数据结构来实现。在类加载完成时就记录下对象中什么地方存放了什么计算出来，JIT编译时也会在特定的位置记录下栈和寄存器中哪些位置存放的是引用。这样一来，GC时就可以直接得到这些信息。

#### 安全点（Safe point）

- 有了OopMap，可以快速完成GC根节点枚举，但是如果对所有指令都生成对应的OopMap，会需要大量的额外空间，GC的空间成本太高。

- 实际上HotSpot只在特定位置生成OopMap，这些位置称为安全点（Safepoint），即程序只有在到达安全点时才能暂停。

- 安全点的数量不能多也不能少，其选定是以程序“是否具有长时间执行的特征”为标准。比如指令序列复用、方法调用、循环跳转、异常跳转等。这些地方才会产生安全点。

- 如何让正在运行的线程在发生GC时都位于安全点？

- - 抢先式中断

  - - 发生GC时，先让所有线程中断，然后检查其是否在安全点，如果不在，则恢复线程，让它跑到安全点再中断。
    - **几乎没人用这种方式**

  - 主动式中断

  - - 当需要GC时设置一个标志，所有的线程都需要去主动轮询，发现该标志位true时就自己中断。
    - 轮询的位置一般和安全点重合。

#### 安全区域（Safe Region）

- 安全点只是针对正在运行的线程，但是当线程处于blocked或者sleep时，就无法响应JVM的中断请求。也不能对其分配CPU时间让它运行到安全点，所以需要安全区域
- 安全区域是指在一段代码中，引用关系不会发生变化。在这个区域中任意地方进行GC都是安全的，可以将安全区域看作是扩展了的安全点。

